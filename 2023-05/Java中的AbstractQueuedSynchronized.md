## AQS概要
AbstractQueuedSynchronizer（AQS）是Java中一个非常重要的同步器，它是实现锁和其他同步工具的基础。AQS提供了一种实现阻塞锁和相关同步器（如Semaphore、CountDownLatch、ReentrantLock等）的框架，它是Java并发包中的核心类之一。

AQS的核心思想是，如果一个线程需要获取锁，但是锁已经被其他线程占用了，那么这个线程就会被阻塞，直到锁被释放。AQS通过一个FIFO的等待队列来管理等待获取锁的线程，当锁被释放时，AQS会从等待队列中唤醒一个线程来获取锁。

AQS的实现是基于模板方法模式的，它定义了一些抽象方法，由子类来实现具体的同步逻辑。AQS的核心方法是acquire()和release()，它们分别对应获取锁和释放锁的操作。在acquire()方法中，如果锁已经被占用，当前线程就会被阻塞，直到锁被释放；在release()方法中，AQS会释放锁，并唤醒等待队列中的一个线程来获取锁。

总之，AQS是Java中实现锁和其他同步工具的基础，它提供了一种通用的框架来实现阻塞锁和相关同步器。如果你想深入了解Java并发编程，那么AQS是必须要掌握的一个知识点。

## AQS中同步队列
在AQS中，同步队列不止一个，它包括了两种类型的队列：同步队列和条件队列。

同步队列是AQS中的核心数据结构，它是一个FIFO的双向链表，用于存储等待获取锁的线程。当一个线程尝试获取锁时，如果锁已经被其他线程占用，那么这个线程就会被加入到同步队列的尾部，等待锁被释放后再次尝试获取锁。

条件队列是AQS中的另一个队列，它是基于同步队列实现的。条件队列用于实现Condition接口，它允许线程在某个条件满足时等待，而不是一直自旋尝试获取锁。当一个线程调用Condition的await()方法时，它会释放锁并进入条件队列等待，当另一个线程调用Condition的signal()方法时，它会从条件队列中唤醒一个等待线程，并将其加入到同步队列中等待获取锁。

因此，AQS中包含了两种类型的队列：同步队列和条件队列。同步队列用于存储等待获取锁的线程，而条件队列用于实现Condition接口，允许线程在某个条件满足时等待。

## 核心方法


## Condition await后再唤醒流程
在Condition的await()方法中，当线程被唤醒后，它会重新尝试获取锁，并将自己加入到AQS的同步队列中等待获取锁。这是因为在调用await()方法时，线程会释放锁并进入条件队列等待，当另一个线程调用signal()方法时，它会从条件队列中唤醒一个等待线程，并将其加入到AQS的同步队列中等待获取锁。

具体来说，当一个线程调用Condition的await()方法时，它会创建一个Node节点，并将其加入到条件队列中等待。当另一个线程调用Condition的signal()方法时，它会从条件队列中取出一个等待线程，并将其加入到AQS的同步队列中等待获取锁。当被唤醒的线程重新尝试获取锁时，它会将自己加入到AQS的同步队列中等待获取锁。

因此，在Condition的await()方法被唤醒后，Node节点会被加入到AQS的同步队列中等待获取锁。